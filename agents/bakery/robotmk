#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-

# (c) 2020 Simon Meggle <simon.meggle@elabit.de>

# This file is part of RobotMK
# https://robotmk.org
# https://github.com/simonmeggle/robotmk

# RobotMK is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 3.  This file is distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import cmk.utils.paths
import os
import yaml
import re
import copy
from cmk.utils.exceptions import MKGeneralException


# TODO: set logging True/False

def bake_robotmk(opsys, conf, conf_dir, plugins_dir):
    # ALWAYS (!) make a deepcopy of the conf dict. Even if you do not change 
    # anything on it, there are strange changes ocurring while building the 
    # packages of OS. A deepcopy solves this completely. 
    myconf = copy.deepcopy(conf)
    if opsys not in ['windows', 'linux']:
        raise MKGeneralException(
            "Error in bakery plugin 'robotmk': Robotmk is only supported on Windows and Linux.")
    config = RMKConfigAdapter(myconf, opsys)
    # I) Copy the plugin (use .py extension on Windows)
    shutil.copy2(
        cmk.utils.paths.local_agents_dir + '/plugins/robotmk', 
        str(plugins_dir) + '/' + config.os_pluginname
        )
    # II) Generate YML config file  
    with open(conf_dir + "/robotmk.yml","w") as robotmk_yml:
        robotmk_yml.write(header)
        yaml.safe_dump(
            config.cfg_dict, 
            robotmk_yml, 
            line_break=config.os_newline, 
            encoding='utf-8', 
            allow_unicode=True,
            sort_keys=True)

class RMKConfigAdapter():
    _DEFAULTS = {
        'windows': {
            'newline'           : "\r\n",  
            'robotdir'          : "C:\\ProgramData\\checkmk\\agent\\robot",  
            'pluginname'        : 'robotmk.py',
        },
        'linux': {
            'newline'           : "\n",   
            'robotdir'          : "/usr/lib/check_mk_agent/robot", 
            'pluginname'        : 'robotmk',
        },
        'posix': {
            'newline'           : "\n",   
            'robotdir'          : "/usr/lib/check_mk_agent/robot", 
            'pluginname'        : 'robotmk',
        },
        'noarch': {
            'cache_time'        : 900,
        }
    }
    def __init__(self, conf, opsys):
        self.os_newline = self.get_os_default('newline')
        self.os_pluginname = self.get_os_default('pluginname')
        execution_mode = conf['execution_mode'][0]
        self.cfg_dict = {
            'global': {},
            'suites': {},
        }
        global_dict = self.cfg_dict['global']
        suites_dict = self.cfg_dict['suites']
        global_dict['agent_output_encoding'] = conf['agent_output_encoding']
        global_dict['transmit_html'] = conf['transmit_html']
        global_dict['logging'] = conf['logging']
        global_dict['log_rotation'] = conf['log_rotation']
        global_dict['robotdir'] = conf.get('robotdir', self._DEFAULTS[opsys]['robotdir'])['robotdir']
        global_dict['execution_mode'] = execution_mode
        
        # mode_conf:
        # >> suite tuples, cache, execution
        mode_conf = conf['execution_mode'][1]
        # mode specific settings
        # Because of the WATO structure ("function follows form") we do not have 
        # keys here, but only a list of Tuples. Depending on the mode, fields
        # are hidden, the indizes my vary! 
        #                        serial       parallel      external      idx
        # global
        #   cache_time           x                          x             1
        #   execution_interval   x                                        0
        # suite
        #   cache_time                        x             x
        #   execution_interval                x

        if execution_mode in ['agent_serial','external']: 
            global_dict['cache_time'] = mode_conf[1]
            if execution_mode == 'agent_serial': 
                global_dict['execution_interval'] = mode_conf[2]
        # suite_tuple:
        # >> path, tag, piggyback, robot_params{}, cachetime, execution_int         
        suite_tuples = mode_conf[0]['suites']
        for suite_tuple in suite_tuples:
            path = suite_tuple[0]
            tag = suite_tuple[1].get('tag', None)
            # generate a unique ID (path_tag)
            suiteid = make_suiteid(path,tag)
            piggybackhost = suite_tuple[2].get('piggybackhost',None)
            robot_param_dict = suite_tuple[3].get('robot_params', {})
            timing_dict = {}
            if execution_mode in ['agent_parallel','external']: 
                timing_dict.update({'cache_time': suite_tuple[4]})
                if execution_mode == 'agent_parallel': 
                    timing_dict.update({'execution_interval': suite_tuple[5]})

            # Variables: transform the var 'list of tuples' into a dict. 
            vardict = {}
            for (k1,v1) in robot_param_dict.iteritems():
                if k1 == 'variable':
                    for t in v1:
                        vardict.update({t[0]: t[1]})
            robot_param_dict['variable'] = vardict
            suitedict = {
                'path': path, 
                'tag' : tag, 
                'piggybackhost': piggybackhost, 
            }
            suitedict.update(robot_param_dict)
            suitedict.update(timing_dict)

            self.cfg_dict['suites'].update({
                suiteid : suitedict
            })


    def get_os_default(self, setting):
        '''Read a setting from the DEFAULTS hash. If no OS setting is found, try noarch.
        Args:
            setting (str): Setting name
        Returns:
            str: The setting value
        '''
        value = self._DEFAULTS[os.name].get(setting, None)
        if value is None:
            value = self._DEFAULTS['noarch'].get(setting, None)
            if value is None:
                # TODO: Exception
                pass
        return value


def make_suiteid(robotpath, tag): 
    '''Create a unique ID from the Robot path (dir/.robot file) and the tag. 
    with underscores for everything but letters, numbers and dot.'''
    composite = "%s_%s" % (robotpath, tag)
    outstr =  re.sub('[^A-Za-z0-9\.]', '_', composite)
    # make underscores unique
    return re.sub('_+', '_', outstr).lower()

bakery_info["robotmk"] = {
    "bake_function": bake_robotmk,
    "os": ["linux", "windows"],
}

header = """# This file is part of RobotMK, a module for the integration of Robot
# framework test results into Checkmk.
#
# https://robotmk.org
# https://github.com/simonmeggle/robotmk
# https://robotframework.org/#tools\n\n"""
