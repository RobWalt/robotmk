#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-

# (c) 2020 Simon Meggle <simon.meggle@elabit.de>

# This file is part of RobotMK
# https://robotmk.org
# https://github.com/simonmeggle/robotmk

# RobotMK is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 3.  This file is distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import tempfile
import os
import re
import time
import ast
import datetime
from pprint import pprint
import xml.etree.ElementTree as ET
from operator import add, sub

iam = "robotmk"

STATES = {
    0: 'OK',
    1: 'WARNING',
    2: 'CRITICAL',
    3: 'UNKNOWN',
}

# GRIFFEL WEG!! MUSS SEIN!
inventory_robotmk_rules = []

# info = one __or more__ robot XML results concatenated 
def parse_robot(info):
    robot_discovery_level = get_setting('robot_discovery_level',[])
    # stringify list of lists
    all_xmlstring = ''.join(map(str, [l[0] for l in info]))
    # identify XMLs
    xmllist = map(lambda x: '<?xml' + x, all_xmlstring.split('<?xml'))[1:]
    robot_results = []
    for xml in xmllist: 
        oxml = ET.fromstring(xml)
        suite, statistics, error =  (oxml.find('./suite'), oxml.find('./statistics'), oxml.find('./errors')) 
        discovery_level = int(pattern_match(robot_discovery_level,suite.attrib['name'], 0))
        if not all(map(lambda x: x != None, [suite, statistics, error])):
            continue
        robot_result = RobotMetrics(suite, statistics, error, discovery_level)
        robot_results.extend(robot_result.data)
    # list of RFSuite objects
    return robot_results

def inventory_robot(robot_results):
    robot_service_prefix = get_setting('robot_service_prefix',[])
    for suite in robot_results:
        prefix = pattern_match(robot_service_prefix, suite.name, '')
        suite_name = "%s%s" % (prefix, suite.name)
        yield suite_name, None
        # uncomment instead of yield to debug this method
        # print suite_name

def check_robot(item, checkgroup_parameters, robot_result):
    if checkgroup_parameters == None: 
        checkgroup_parameters = {}
    robot_discovery_level = get_setting('robot_discovery_level',[])

    for suite in robot_result:
        item_without_prefix = strip_prefix(item)
        if suite.name == item_without_prefix:
            discovery_level = int(pattern_match(robot_discovery_level, item_without_prefix, 0))
            nagios_result = suite.nagios_result_recursive(checkgroup_parameters, discovery_level)
            # worststate
            rc = max(map(lambda x: x[0], nagios_result))
            # First element in nagios_result is a duplicate of the second; begin at index 1
            # Result elements have perfdata tuples on index 3; get only non-empty entries
            perf = [ x[3] for x in nagios_result[1:] if x[3] ]
            output = '\n'.join([ i[1] for i in nagios_result])
            return rc, output, perf

# strips the prefix from the suitename
def strip_prefix(suitename):
    robot_service_prefix = get_setting('robot_service_prefix',[])
    prefix = pattern_match(robot_service_prefix, suitename, '')
    if suitename.startswith(prefix):
        return suitename[len(prefix):]
    else:
        return suitename

# ==============================================================================
# Classes for robot result objects =============================================
# ==============================================================================
class RFObject(object):
    RF_STATE2NAGIOSID = {
        'PASS'  : 0,
        'FAIL'  : 2
    }
    RF_STATE2NAGIOSSTATUS = {
        'PASS'  : 'OK',
        'FAIL'  : 'CRIT'
    }

    def __init__(self, id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches=[]):
        self.id = id
        # level_absolute is the absolute position in the suite tree. A RFMetrics object 
        # with a discovery_level of 2 for example can result in on or more suites
        # which each have a level_absolute if 2.  
        self.level_absolute = level_absolute
        # level_relative begins starts for each suites/tests/keywords at 0 (to control output_depth for suites/kws)
        self.level_relative = level_relative
        self.name = name
        self.status = status
        self.starttime = starttime
        self.endtime = endtime
        self.elapsedtime = elapsedtime
        # FIXME assert branches type
        self.branches = branches

    @property
    def abbr(self):
        return '[%s]' % str(self)[:1].upper()

    @property
    def nagios_stateid(self):
        return self.RF_STATE2NAGIOSID[self.status]

    @property
    def nagios_status(self):
        return self.RF_STATE2NAGIOSSTATUS[self.status]

    @property
    def nagios_perfdata(self):
        return ( self.name, self.elapsedtime)

    # returns status and RC of this node and subnodes
    def nagios_result_recursive(self, checkgroup_parameters, discovery_level, depth_limit_inherited=None ):
        # If the pattern for <setting> matches, return the value (if tuple) or True
        def get_pattern_value(setting):
            setting_keyname = getattr(self, "%s_dict_key" % setting)
            patterns = checkgroup_parameters.get(setting, {}).get(setting_keyname, [])
            return pattern_match(patterns, self.name)

        this_runtime_threshold = None
        elapsed_sec = None
        # Corner case: check for a failed test; it has no elapsed_sec
        if isinstance(self, RFTest) and self.critical: 
            my_rc = 2
            padding = (discovery_level - self.level_absolute)* -1 * u"\u2504"
            my_out = ("%s %s %s '%s': %s (CRITICAL: %s)" % (padding, self.symbol_nok, self.abbr, self.name, self.status, self.text)).strip()
            my_err = "%s '%s' failed with '%s'" % (str(self), self.name, self.text)
        else: 
            # RUNTIME EVALUTATION --- How long did Suites/Tests/Keywords run? 
            this_runtime_threshold = get_pattern_value('runtime_threshold')
            elapsed_sec = self.elapsedtime/float(1000)
            if this_runtime_threshold and elapsed_sec >= this_runtime_threshold: 
                my_rc = 1
                runtime_str = "%.2fs, WARNING: > %.2fs" % (elapsed_sec, this_runtime_threshold)
                padding = (discovery_level - self.level_absolute)* -1 * u"\u2504"
                my_out = ("%s %s %s '%s': %s (%s)" % (padding, self.symbol_nok, self.abbr, self.name, self.status, runtime_str)).strip()
                my_err = "%s '%s' over runtime" % (str(self), self.name)
            else: 
                my_rc = self.nagios_stateid
                runtime_str = "%.2fs" % elapsed_sec
                padding = (discovery_level - self.level_absolute)* -1 * u"\u2504"
                my_out = ("%s %s %s '%s': %s (%s)" % (padding, self.symbol_ok, self.abbr, self.name, self.status, runtime_str)).strip()
                my_err = ''

        # PERFDATA ---- Which elemens should produce performance data? 
        this_perfdata_value = get_pattern_value('perfdata_creation')
        my_perfdata = None
        if this_perfdata_value and elapsed_sec != None: 
            perflabel = "%s_%s" % (self.id, self.name.replace(' ', '_'))
            if this_runtime_threshold: 
                my_perfdata = (perflabel, "%.2f" % elapsed_sec, "%.2f" % this_runtime_threshold)
            else: 
                my_perfdata = (perflabel, "%.2f" % elapsed_sec)

        

        # OUTPUT DEPTH --- how deep can we descend in nested suites/keywords?  
        this_depth_limit = get_pattern_value('output_depth')

        # i = inherited depth
        # t = this depth
        # nx = next depth

        # i  t  nx
        # -----------
        # n  n. n    #3
        # n  0. -1   #4
        # n  2. 1    #1 
        #   
        # 0. n  -1   #2
        # 0  0. -1   #4
        # 0  2. 1    #1 
        #   
        # 2  n  1    #2
        # 2  0. -1   #4
        # 2  2. 1    #1 

        if this_depth_limit == None or this_depth_limit > 0: 
            if this_depth_limit > 0: 
                #1 we can descend
                next_depth_limit = this_depth_limit -1 
            else:  
                # no pattern for this, decide from inherited value
                if depth_limit_inherited >= 0:    
                    #2
                    next_depth_limit = depth_limit_inherited -1 
                else: 
                    #3
                    next_depth_limit = None
        else: 
            #4 there's 0 defined, this overwrites inherited depth
            next_depth_limit = -1

        # list of tuples holding all sub elements
        my_result_branches = []
        # Let's descend
        if next_depth_limit == None or next_depth_limit > -1: 
            sublists = [ subel.nagios_result_recursive(checkgroup_parameters, discovery_level, next_depth_limit) for subel in self.branches ]
            # avoid nesting, flat the list
            for sublist in sublists: 
                for subitem in sublist: 
                    my_result_branches.append(subitem)  

        # Are we on the last recursion? 
        if self.level_relative == 0 and str(self) == "Suite": 
            elements_with_errors = filter(lambda x: x[2], my_result_branches)
            errors = ', '.join([ x[2] for x in elements_with_errors])
            worst_stateid = max(map(lambda x: x[0], my_result_branches))
            worststate = STATES[worst_stateid]
            # duplicate the first line for short_output
            # first line can contain the end timestamp 
            endtime_str = ""
            if bool(checkgroup_parameters.get('includedate')):
                o_endtime = datetime.datetime.strptime(self.endtime, '%Y%m%d %H:%M:%S.%f')
                endtime_str = ", last execution: %s" % o_endtime.strftime('%m/%d, %H:%M:%S')
            my_out_firstline = "%s%s, %s: %s" % (my_out, endtime_str, worststate, errors)
            my_result_firstline = [(my_rc, my_out_firstline)]
        else:
            my_result_firstline = []
            
        my_result = [(my_rc, my_out, my_err, my_perfdata)]
        return my_result_firstline + my_result + my_result_branches


class RFSuite(RFObject):
    def __init__(self, id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches=[]):
        super(RFSuite, self).__init__(id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches)

    def __str__(self):
        return "Suite"

    @property
    def symbol_ok(self):
        return u"\u25ef"
    @property
    def symbol_nok(self):
        return u"\u2b24"

    @property
    def output_depth_dict_key(self):
        return "output_depth_suites"
    @property
    def runtime_threshold_dict_key(self):
        return "runtime_threshold_suites"
    @property
    def perfdata_creation_dict_key(self):
        return "perfdata_creation_suites"

class RFTest(RFObject):
    def __init__(self, id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches=[], critical=False, text=''):
        super(RFTest, self).__init__(id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches)
        self.critical = critical
        self.text = text

    def __str__(self):
        return "Test"
    @property
    def symbol_ok(self):
        return u"\u25a1"
    @property
    def symbol_nok(self):
        return u"\u25a0"

    # not really needed, 'cause tests cannot be nested, hence there is no depth. 
    # This is only to suppress nasty warnings. 
    @property
    def output_depth_dict_key(self):
        return "output_depth_tests"
    @property
    def runtime_threshold_dict_key(self):
        return "runtime_threshold_tests"
    @property
    def perfdata_creation_dict_key(self):
        return "perfdata_creation_tests"        

class RFKeyword(RFObject):
    def __init__(self, id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches=[]):
        super(RFKeyword, self).__init__(id, level_absolute, level_relative, name, status, starttime, endtime, elapsedtime, branches)

    def __str__(self):
        return "Keyword"

    @property
    def symbol_ok(self):
        return u"\u25cb"
    @property
    def symbol_nok(self):
        return u"\u25cf"

    # which key in dict output_depth is holding the values for keywords
    @property
    def output_depth_dict_key(self):
        return "output_depth_keywords"
    @property
    def runtime_threshold_dict_key(self):
        return "runtime_threshold_keywords"
    @property
    def perfdata_creation_dict_key(self):
        return "perfdata_creation_keywords"


# ==============================================================================
# Visitor Class for Robot Result ===============================================
# ==============================================================================
class RobotMetrics(object):
    def __init__(self, suite, statistics, error, discovery_level=0):
        self.discovery_level = discovery_level
        self.data = []
        self.visit_suite(suite, statistics, error)

    def visit_suite(self, suite, statistics, error, level_absolute=0):
        # (A suite can have suites and tests in it)
        subsuites = suite.findall('suite')
        subtests = suite.findall('test')
        # Subsuites
        if subsuites:
            sub_objects = [ self.visit_suite(subsuite, statistics, error, level_absolute+1) for subsuite in subsuites ]
        # Testcases
        elif subtests:
            sub_objects = [ self.visit_test(test, statistics, error, level_absolute+1) for test in subtests ]

        suite_node = RFSuite(
            suite.attrib['id'], 
            level_absolute, 
            level_absolute - self.discovery_level, 
            suite.attrib['name'], 
            suite.find('status').attrib['status'], 
            suite.find('status').attrib['starttime'], 
            suite.find('status').attrib['endtime'], 
            get_elapsed_time(
                suite.find('status').attrib['starttime'], 
                suite.find('status').attrib['endtime'] 
            ),
            sub_objects)


        if level_absolute == self.discovery_level:
            self.data.append(suite_node)
        else:
            return suite_node

    def visit_test(self, test, statistics, error, level_absolute):
        # (A test can only have keywords in it)
        keywords = test.findall('kw')
        if keywords:
            subkw_objects = [ self.visit_keyword(keyword, statistics, error, level_absolute+1, 0, test.attrib['id'], ind+1) for ind, keyword in enumerate(keywords) ]
        
        # ElementTree's XPath support is somehow... limited (no 'and')

        # Attention. Robot has another understanding of what's "ciritcal": "All test cases are considered critical by default". 
        # (http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#setting-criticality)
        # For Robot, a FAILed test only can let the whole test run fail if it is marked as 'critical'.
        # For this reason, lets check for 'critical' as precondition and 'status' if it was an error.   
        if test.find('status[@status="FAIL"]') != None and test.find('status[@critical="yes"]') != None: 
            critical = True
            text = test.find('status[@critical="yes"]').text
        else:
            critical = False
            text = ''


        # level_relative = always 0, because tests are not nested. 
        test_node = RFTest(
                test.attrib['id'], 
                level_absolute, 
                0, 
                test.attrib['name'],
                test.find('status').attrib['status'], 
                test.find('status').attrib['starttime'], 
                test.find('status').attrib['endtime'], 
                get_elapsed_time(
                    test.find('status').attrib['starttime'], 
                    test.find('status').attrib['endtime'] 
                ),
                subkw_objects, 
                critical,
                text

        )
        if level_absolute == self.discovery_level:
            self.data.append(test_node)
        else:
            return test_node

    def visit_keyword(self, keyword, statistics, error, level_absolute, level_relative, parent_id, ind):
        keyword_id = "%s-k%s" % (parent_id, ind)

        # (A keyword can have keywords in it)
        keywords = keyword.findall('kw')
        subkw_objects = ()
        if keywords:
            subkw_objects = [ self.visit_keyword(subkeyword, statistics, error, level_absolute+1, level_relative+1, keyword_id, ind+1) for ind, subkeyword in enumerate(keywords) ]

        keyword_node = RFKeyword(
                keyword_id, 
                level_absolute, 
                level_relative, 
                keyword.attrib['name'], 
                keyword.find('status').attrib['status'], 
                keyword.find('status').attrib['starttime'], 
                keyword.find('status').attrib['endtime'], 
                get_elapsed_time(keyword.find('status').attrib['starttime'], keyword.find('status').attrib['endtime'] ),
                subkw_objects)
        if level_absolute == self.discovery_level:
            self.data.append(keyword_node)
        else:
            return keyword_node


#   _          _                 
#  | |        | |                
#  | |__   ___| |_ __   ___ _ __ 
#  | '_ \ / _ \ | '_ \ / _ \ '__|
#  | | | |  __/ | |_) |  __/ |   
#  |_| |_|\___|_| .__/ \___|_|   
#               | |              
#               |_|   

# Determine if a list of patterns matches.
# If list elements are tuples of (pattern,value), return the value
# If list elements are patterns, return bool
# If nothing matches return the default
def pattern_match(patterns, name, default=None):
    for elem in patterns:
        if type(elem) == tuple: 
            if re.match(elem[0], name):
                return elem[1]
        else:
            if re.match(elem, name):
                return True
    return default

# two helper funcs to get host settings
def get_host_extra_conf_merged():
    return host_extra_conf_merged(host_name(), eval("inventory_"+iam+"_rules"))
def get_setting(setting, defaultvalue):
    settings = get_host_extra_conf_merged()
    return settings.get(setting,defaultvalue)

# all following borrowed from robot-framework
def get_elapsed_time(start_time, end_time):
    """Returns the time between given timestamps in milliseconds."""
    if start_time == end_time or not (start_time and end_time):
        return 0
    if start_time[:-4] == end_time[:-4]:
        return int(end_time[-3:]) - int(start_time[-3:])
    start_millis = timestamp_to_millis(start_time)
    end_millis = timestamp_to_millis(end_time)
    # start/end_millis can be long but we want to return int when possible
    return int(end_millis - start_millis)

def timestamp_to_millis(timestamp):
    Y, M, D, h, m, s, millis = split_timestamp(timestamp)
    secs = time.mktime(datetime.datetime(Y, M, D, h, m, s).timetuple())
    return roundup(1000*secs + millis)

def split_timestamp(timestamp):
    years = int(timestamp[:4])
    mons = int(timestamp[4:6])
    days = int(timestamp[6:8])
    hours = int(timestamp[9:11])
    mins = int(timestamp[12:14])
    secs = int(timestamp[15:17])
    millis = int(timestamp[18:21])
    return years, mons, days, hours, mins, secs, millis   

def roundup(number, ndigits=0, return_type=None):
    result = round(number, ndigits)
    if not return_type:
        return_type = float if ndigits > 0 else int
    return return_type(result)


#                   _       
#                  (_)      
#   _ __ ___   __ _ _ _ __  
#  | '_ ` _ \ / _` | | '_ \ 
#  | | | | | | (_| | | | | |
#  |_| |_| |_|\__,_|_|_| |_|
                          
                          


if __name__ == "__main__":    
    global check_info
    check_info = {}

check_info['robotmk'] = {
    "parse_function": parse_robot,
    "inventory_function": inventory_robot,
    "check_function": check_robot,
    "service_description": "Robot",
    "group": "robotmk",
    "has_perfdata": True
}

if __name__ == "__main__":
    #import ipdb
    #ipdb.set_trace(context=5)

    debugsets = [
        {
            'discovery_level': 0,
            'paramfile': 'params.py',
            'suite': '1S_3S_2S_3T',
        },
        {
            'discovery_level': 0,
            'paramfile': 'params.py',
            'suite': '1S_3S_2S_3T',
        },
    ]
    debugset = debugsets[0]

    global inventory_robotmk_rules
    inventory_robotmk_rules = ast.literal_eval(
        open('test/fixtures/inventory_robotmk_rules/discovery_slvel_%d.py' % debugset['discovery_level']).read())
    global host_extra_conf_merged
    def host_extra_conf_merged(hostname, inventory_robotmk_rules):
        return inventory_robotmk_rules[0]['value']


    global host_name
    def host_name():
        return "localhost"

    try: 
        checkgroup_parameters = ast.literal_eval(open('test/fixtures/checkgroup_parameters/' % debugset['paramfile'], 'r').read())
    except: 
        checkgroup_parameters = None
    # ipdb.set_trace(context=5)
    datafile = 'test/fixtures/robot/%s/output.json' % debugset['suite']
    mk_output = ast.literal_eval(open(datafile, 'r').read())

    # PARSE
    parsed = parse_robot(mk_output)
    # INVENTORY
    inventory = inventory_robot(parsed)
    # CHECK
    state, msg, perfdata = check_robot("1S 3S 2S 3T", checkgroup_parameters, parsed)
    # state, msg, perfdata = check_robot("A-Suites", checkgroup_parameters, parsed)
    # state, msg, perfdata = check_robot("A-suite1", checkgroup_parameters, parsed)
    # state, msg, perfdata = check_robot("A-Tes.*", checkgroup_parameters, parsed)
    print "Debugger ended."

